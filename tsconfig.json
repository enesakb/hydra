// ============================================================================
// HYDRA — Revenue Engine Orchestrator
// Manages all 6 revenue engines based on DNA allocation
// ============================================================================

import { Logger } from '../state/logger.js';
import { WalletManager } from '../identity/wallet.js';
import { ModelRouter } from '../ai/router.js';
import { Constitution } from '../core/constitution.js';
import { Database } from '../state/db.js';
import {
  type AgentDNA,
  type ActionDescription,
  type Position,
  type Task,
  type RevenueReport,
  RevenueEngine,
} from '../core/types.js';

interface ActionResult {
  success: boolean;
  revenue?: number;
  cost?: number;
  error?: string;
  data?: unknown;
}

export class RevenueOrchestrator {
  private dna: AgentDNA;
  private wallet: WalletManager;
  private modelRouter: ModelRouter;
  private constitution: Constitution;
  private logger: Logger;
  private db: Database;

  private activePositions: Position[] = [];
  private pendingTasks: Task[] = [];
  private revenueHistory: RevenueReport[] = [];
  private totalRevenue: number = 0;
  private totalCosts: number = 0;

  constructor(
    dna: AgentDNA,
    wallet: WalletManager,
    modelRouter: ModelRouter,
    constitution: Constitution,
    logger: Logger,
    db: Database,
  ) {
    this.dna = dna;
    this.wallet = wallet;
    this.modelRouter = modelRouter;
    this.constitution = constitution;
    this.logger = logger;
    this.db = db;
  }

  async initialize(): Promise<void> {
    this.logger.info('Revenue engines initializing...', {
      allocation: this.dna.revenueAllocation,
    });

    // Initialize each engine based on DNA allocation
    const engines = this.getActiveEngines();
    this.logger.info(`Active engines: ${engines.join(', ')}`);
  }

  async shutdown(): Promise<void> {
    this.logger.info('Revenue engines shutting down...');
    // Close all positions gracefully
    for (const position of this.activePositions) {
      this.logger.info(`Closing position: ${position.symbol} ${position.side}`);
    }
    this.activePositions = [];
  }

  /**
   * Get engines that have > 5% allocation in DNA.
   */
  private getActiveEngines(): RevenueEngine[] {
    const engines: RevenueEngine[] = [];
    const alloc = this.dna.revenueAllocation;

    if (alloc.trading > 0.05) engines.push(RevenueEngine.ALPHA);
    if (alloc.predictions > 0.05) engines.push(RevenueEngine.ORACLE);
    if (alloc.tasks > 0.05) engines.push(RevenueEngine.MERCENARY);
    if (alloc.apis > 0.05) engines.push(RevenueEngine.FORGE);
    if (alloc.defi > 0.05) engines.push(RevenueEngine.HARVEST);
    if (alloc.spawning > 0.05) engines.push(RevenueEngine.GENESIS);

    return engines;
  }

  // ─── ALPHA ENGINE: Crypto Trading ────────────────────────────────────────

  async executeTrade(action: ActionDescription): Promise<ActionResult> {
    this.logger.revenue('ALPHA', 0, { action: action.description });

    // Constitution check
    const check = this.constitution.checkAction(action);
    if (!check.passed) {
      return { success: false, error: `Blocked by Law ${check.law}: ${check.reason}` };
    }

    try {
      // TODO: Implement actual trading via ccxt
      // For now, simulate
      this.logger.info(`[ALPHA] Would execute trade: ${action.description}`);

      return { success: true, revenue: 0, cost: 0.001 };
    } catch (error) {
      this.logger.error('[ALPHA] Trade failed', { error });
      return { success: false, error: String(error) };
    }
  }

  /**
   * Analyze market and generate trade signals using AI.
   */
  async analyzeMarket(symbol: string): Promise<{
    signal: 'buy' | 'sell' | 'hold';
    confidence: number;
    reasoning: string;
  }> {
    const response = await this.modelRouter.complete({
      system: `You are a crypto market analyst. Analyze the following market data and provide a trading signal.
        Be conservative. Only recommend trades with high confidence.
        Respond in JSON: { "signal": "buy"|"sell"|"hold", "confidence": 0-1, "reasoning": "..." }`,
      messages: [
        {
          role: 'user',
          content: `Analyze ${symbol} for a potential trade. Consider current market conditions, recent price action, and risk factors.`,
          timestamp: new Date(),
        },
      ],
    });

    try {
      const result = JSON.parse(response.content);
      return result;
    } catch {
      return { signal: 'hold', confidence: 0, reasoning: 'Failed to parse analysis' };
    }
  }

  // ─── ORACLE ENGINE: Prediction Markets ───────────────────────────────────

  async analyzePredictionMarket(marketId: string): Promise<{
    position: 'yes' | 'no' | 'skip';
    confidence: number;
    suggestedSize: number;
  }> {
    // TODO: Fetch market data from Polymarket/Manifold
    // Use AI to analyze probability vs market price
    this.logger.info(`[ORACLE] Analyzing market: ${marketId}`);

    return { position: 'skip', confidence: 0, suggestedSize: 0 };
  }

  // ─── MERCENARY ENGINE: Task Marketplace ──────────────────────────────────

  async browseTaskMarketplace(): Promise<Task[]> {
    // TODO: Connect to agent marketplace
    this.logger.info('[MERCENARY] Browsing task marketplace...');
    return [];
  }

  async bidOnTask(task: Task): Promise<ActionResult> {
    this.logger.info(`[MERCENARY] Bidding on task: ${task.title} ($${task.bountyUSD})`);
    return { success: true };
  }

  // ─── FORGE ENGINE: API Monetization ──────────────────────────────────────

  async deployService(action: ActionDescription): Promise<ActionResult> {
    this.logger.info(`[FORGE] Deploying service: ${action.description}`);
    return { success: true, cost: 0.01 };
  }

  // ─── HARVEST ENGINE: DeFi Yield ──────────────────────────────────────────

  async scanYieldOpportunities(): Promise<Array<{
    protocol: string;
    apy: number;
    risk: 'low' | 'medium' | 'high';
    minDeposit: number;
  }>> {
    this.logger.info('[HARVEST] Scanning yield opportunities...');
    return [];
  }

  // ─── GENESIS ENGINE: Agent Spawning ──────────────────────────────────────

  async canSpawn(): Promise<boolean> {
    const balance = await this.wallet.totalValueUSD();
    return balance > 100; // Minimum $100 to spawn
  }

  // ─── Getters ─────────────────────────────────────────────────────────────

  getActivePositions(): Position[] {
    return [...this.activePositions];
  }

  getPendingTasks(): Task[] {
    return [...this.pendingTasks];
  }

  getTotalRevenue(): number {
    return this.totalRevenue;
  }

  getTotalCosts(): number {
    return this.totalCosts;
  }

  getNetRevenue(): number {
    return this.totalRevenue - this.totalCosts;
  }
}
